学习笔记
# 树、二叉树、二叉搜索树
## 树
非线性数据结构、分层。
路径：顺着节点的边从一个节点走到另一个节点，所经过的节点的顺序排列就称为“路径”。
根节点
子节点
兄弟节点
叶子节点
子树
节点高度（Height）：节点到叶子节点的最长路径（边数）
节点深度（Depth）：从根节点移动到该节点的边数
节点层数（Level）节点深度 + 1
## 二叉树
每个节点最多有两个子节点
左子节点
右子节点
满二叉树：除叶子节点外，其他节点都有子节点
完全二叉树：除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点（数组存储，节省空间）
二叉树存储实现：
基于指针或者引用的二叉链式存储法
基于数组的顺序存储法
如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。
## 二叉树遍历
前序遍历：根节点 --> 左子树 --> 右子树
中序遍历：左子树 --> 根节点 --> 右子树
后序遍历：左子树 --> 右子树 --> 根节点
递归公式
前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)
中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)
后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
## 二叉查找树
在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。
查找操作：
如果要查找的数据比根节点的值小，那就在左子树中递归查找；
如果要查找的数据比根节点的值大，那就在右子树中递归查找。
插入操作：
如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；
如果不为空，就再递归遍历右子树，查找插入位置。
如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；
如果不为空，就再递归遍历左子树，查找插入位置。
删除操作：
如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null；
如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了；
如果要删除的节点有两个子节点，需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点；
其他操作：
快速地查找最大节点和最小节点、前驱节点和后继节点；
中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)（二叉排序树）
时间复杂度
不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)


# 堆、二叉堆
## 堆
特性：迅速找到一堆数中最大或最小值的数据结构。
大顶堆（大根堆）
小顶堆（小根堆）
二叉堆、斐波那契堆

大顶堆API：
find-max: O(1)
delete-max: O(logN)
insert(create): O(logN) or O(1)

## 二叉堆性质
通过完全二叉树实现；
二叉堆（大顶）性质：
1. 一棵完全树；
2. 树中任意节点值>=子节点值

实现细节：
通过数组实现；
父子节点位置关系：
索引为i的节点的左子节点索引是（2*i+1）
索引为i的节点的右子节点索引是（2*i+2）
索引为i的节点的父节点索引为floor((i-1)/2)

Insert插入操作：
1. 新元素一律先插入堆的尾部
2. 依次向上调整整个堆的结构（一直到根即可）
HeapifyUp

Insert - O(logN)

Delete Max 删除堆顶操作 O(logN)
1. 将堆尾元素替换到顶部（即堆顶被替代删除掉）
2. 依次从根部向下调整整个堆的结构（一直到堆尾即可）
HeapifyDown


## 图
属性
Graph(V, E)
V-vertex: 点
1. 度 - 入度和出度
2. 点与点之间： 是否联通

E-edge:
1. 有向和无向（单行线）
2. 权重（边长）

无向无权图
有向无权图
无向有权图
有向有全图

常见算法：
DFS
BFS